import React, { useEffect, useState } from 'react';
import {
  Box, Typography, Card, CardContent, Table, TableBody, TableCell, TableContainer, TableHead, TableRow, Paper,
  Button, IconButton, Dialog, DialogTitle, DialogContent, DialogActions, TextField, Checkbox, FormControlLabel,
  CircularProgress, Tooltip, Chip, Alert, MenuItem, FormControl, InputLabel, Select, Accordion, AccordionSummary, AccordionDetails, Snackbar
} from '@mui/material';
import Grid from '@mui/material/Grid';
import { Add, Edit, Delete, Group, Schedule, ExpandMore, AutoAwesome } from '@mui/icons-material';
import { useAuth } from '../contexts/AuthContext';
import { classesAPI } from '../services/api';
import Pagination from '@mui/material/Pagination';
import api from '../services/api'; // Added for schedule CRUD
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

interface ClassItem {
  id: number;
  name: string;
  section: string;
  school: number;
  school_name: string;
  academic_year: string;
  capacity: number;
  students_count: number;
  subjects_count: number;
  is_active: boolean;
}

interface StudentItem {
  id: number;
  user: { first_name: string; last_name: string; email: string };
  student_id: string;
  academic_status: string;
}

interface ScheduleItem {
  id: number;
  subject: { name: string };
  teacher_info: { name: string } | null;
  day: string;
  start_time: string;
  end_time: string;
  room: string;
}

const initialForm = {
  name: '',
  section: '',
  academic_year: '',
  capacity: 40,
  is_active: true,
};

const DAYS = [
  { value: 'monday', label: 'Monday' },
  { value: 'tuesday', label: 'Tuesday' },
  { value: 'wednesday', label: 'Wednesday' },
  { value: 'thursday', label: 'Thursday' },
  { value: 'friday', label: 'Friday' },
  { value: 'saturday', label: 'Saturday' },
  { value: 'sunday', label: 'Sunday' },
];
const emptyScheduleForm = {
  day: 'monday',
  start_time: '',
  end_time: '',
  subject: '',
  teacher: '',
  room: '',
};

const Classes: React.FC = () => {
  const { user } = useAuth();
  const canManage = user?.role === 'school_admin' || user?.role === 'principal' || user?.role === 'secretary';
  const [classes, setClasses] = useState<ClassItem[]>([]);
  const [academicYears, setAcademicYears] = useState<string[]>([]);
  const [selectedYear, setSelectedYear] = useState<string>('');
  const [latestYear, setLatestYear] = useState<string>('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [dialogOpen, setDialogOpen] = useState(false);
  const [editingId, setEditingId] = useState<number | null>(null);
  const [form, setForm] = useState(initialForm);
  const [autoGenerateDialog, setAutoGenerateDialog] = useState(false);
  const [autoGenerateLoading, setAutoGenerateLoading] = useState(false);
  const [autoGenerateError, setAutoGenerateError] = useState('');
  const [autoGenerateSuccess, setAutoGenerateSuccess] = useState('');
  const [yearClassCounts, setYearClassCounts] = useState<{[key: string]: number}>({});
  const [yearCountsLoading, setYearCountsLoading] = useState(false);
  const [targetYear, setTargetYear] = useState('');
  const [page, setPage] = useState(1);
  const [pageSize] = useState(12);
  const [totalPages, setTotalPages] = useState(1);
  const [totalCount, setTotalCount] = useState(0);
  const [studentsModal, setStudentsModal] = useState<{ open: boolean; classId: number | null; students: StudentItem[] }>({ open: false, classId: null, students: [] });
  const [scheduleModal, setScheduleModal] = useState<{ open: boolean; classId: number | null; schedule: ScheduleItem[] }>({ open: false, classId: null, schedule: [] });
  const [modalLoading, setModalLoading] = useState(false);
  const [modalError, setModalError] = useState('');
  const [subjects, setSubjects] = useState<any[]>([]);
  const [teachers, setTeachers] = useState<any[]>([]);
  const [scheduleDialogOpen, setScheduleDialogOpen] = useState(false);
  const [editingSchedule, setEditingSchedule] = useState<any | null>(null);
  const [scheduleForm, setScheduleForm] = useState({ ...emptyScheduleForm });
  const [scheduleActionLoading, setScheduleActionLoading] = useState(false);
  const [scheduleSnackbar, setScheduleSnackbar] = useState<{ open: boolean; message: string; severity: 'success' | 'error' }>({ open: false, message: '', severity: 'success' });
  const [includeTeacher, setIncludeTeacher] = useState(true);
  const [includeRoom, setIncludeRoom] = useState(true);
  
  const fetchClasses = async (year?: string, pageNum: number = 1) => {
    setLoading(true);
    setError('');
    try {
      const params: any = { page: pageNum, page_size: pageSize };
      if (year && year !== '') {
        params.academic_year = year;
      }
      console.log('Fetching classes with params:', params);
      const res = await classesAPI.getClasses(params);
      // Handle paginated response
      const classesData = res.data.results || res.data;
      let classesArray = Array.isArray(classesData) ? classesData : [];
      
      console.log('Received classes:', classesArray.length, 'for year:', year);
      
      // If no specific year is selected (All Years), sort by academic year descending
      if (!year || year === '') {
        classesArray = classesArray.sort((a, b) => b.academic_year.localeCompare(a.academic_year));
        console.log('Sorted classes by academic year (descending)');
      }
      
      setClasses(classesArray);
      
      // Update pagination info
      if (res.data.count !== undefined) {
        setTotalCount(res.data.count);
        setTotalPages(Math.ceil(res.data.count / pageSize));
      }
      setPage(pageNum);
    } catch (err) {
      console.error('Error fetching classes:', err);
      setError('Failed to fetch classes.');
    } finally {
      setLoading(false);
    }
  };

  const fetchClassCounts = async () => {
    setYearCountsLoading(true);
    try {
      const counts: {[key: string]: number} = {};
      for (const year of academicYears) {
        const res = await classesAPI.getClasses({ academic_year: year });
        const classesData = res.data.results || res.data;
        counts[year] = Array.isArray(classesData) ? classesData.length : 0;
      }
      setYearClassCounts(counts);
    } catch (err) {
      console.error('Error fetching class counts:', err);
    } finally {
      setYearCountsLoading(false);
    }
  };

  const fetchAcademicYears = async () => {
    try {
      const res = await classesAPI.getAcademicYears();
      setAcademicYears(res.data.academic_years || []);
      setLatestYear(res.data.latest_year || '');
      
      // Fetch class counts for all years
      if (res.data.academic_years && res.data.academic_years.length > 0) {
        await fetchClassCounts();
      }
      
      if (res.data.latest_year && !selectedYear) {
        setSelectedYear(res.data.latest_year);
        fetchClasses(res.data.latest_year, 1);
      } else if (!selectedYear) {
        fetchClasses(undefined, 1);
      }
    } catch (err) {
      console.error('Failed to fetch academic years:', err);
    }
  };

  const handleAutoGenerate = async () => {
    if (!targetYear) {
      setAutoGenerateError('Please enter a target academic year');
      return;
    }

    setAutoGenerateLoading(true);
    setAutoGenerateError('');
    setAutoGenerateSuccess('');

    try {
      const res = await classesAPI.autoGenerateClasses(targetYear);
      setAutoGenerateSuccess(res.data.message);
      setTargetYear('');
      setAutoGenerateDialog(false);
      
      // Refresh academic years and classes
      await fetchAcademicYears();
      setSelectedYear(targetYear);
      await fetchClasses(targetYear, 1);
    } catch (err: any) {
      setAutoGenerateError(err.response?.data?.error || 'Failed to auto-generate classes');
    } finally {
      setAutoGenerateLoading(false);
    }
  };

  const handleYearChange = (year: string) => {
    console.log('Year changed to:', year);
    setSelectedYear(year);
    setPage(1); // Reset to first page when changing year
    // Pass empty string for "All Years" to fetch all classes
    const yearToFetch = year === '' ? undefined : year;
    console.log('Fetching classes for year:', yearToFetch);
    fetchClasses(yearToFetch, 1);
  };

  const handlePageChange = (event: React.ChangeEvent<unknown>, value: number) => {
    setPage(value);
    const yearToFetch = selectedYear === '' ? undefined : selectedYear;
    fetchClasses(yearToFetch, value);
  };

  useEffect(() => {
    fetchAcademicYears();
  }, []);

  const handleOpenDialog = (cls?: ClassItem) => {
    if (cls) {
      setForm({
        name: cls.name,
        section: cls.section,
        academic_year: cls.academic_year,
        capacity: cls.capacity,
        is_active: cls.is_active,
      });
      setEditingId(cls.id);
    } else {
      setForm(initialForm);
      setEditingId(null);
    }
    setDialogOpen(true);
  };

  const handleCloseDialog = () => {
    setDialogOpen(false);
    setEditingId(null);
  };

  const handleFormChange = (field: string, value: any) => {
    setForm(prev => ({ ...prev, [field]: value }));
  };

  const handleFormSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      if (editingId) {
        await classesAPI.updateClass(editingId, form);
      } else {
        await classesAPI.createClass(form);
      }
      // Refresh classes with current filter and page
      const yearToFetch = selectedYear === '' ? undefined : selectedYear;
      fetchClasses(yearToFetch, page);
      // Refresh academic years to update counts
      await fetchAcademicYears();
      setDialogOpen(false);
    } catch (err) {
      setError('Failed to save class.');
    }
  };

  const handleDelete = async (id: number) => {
    if (!window.confirm('Are you sure you want to delete this class?')) return;
    try {
      await classesAPI.deleteClass(id);
      // Refresh classes with current filter and page
      const yearToFetch = selectedYear === '' ? undefined : selectedYear;
      fetchClasses(yearToFetch, page);
      // Refresh academic years to update counts
      await fetchAcademicYears();
    } catch (err) {
      setError('Failed to delete class.');
    }
  };

  const handleViewStudents = async (classId: number) => {
    setStudentsModal({ open: true, classId, students: [] });
    setModalLoading(true);
    setModalError('');
    try {
      const res = await classesAPI.getClassStudents(classId);
      setStudentsModal({ open: true, classId, students: Array.isArray(res.data) ? res.data : [] });
    } catch (err) {
      setModalError('Failed to load students.');
    } finally {
      setModalLoading(false);
    }
  };

  const handleViewSchedule = async (classId: number) => {
    setScheduleModal({ open: true, classId, schedule: [] });
    setModalLoading(true);
    setModalError('');
    try {
      const [scheduleRes, subjectsRes, teachersRes] = await Promise.all([
        classesAPI.getClassSchedule(classId),
        // Use the correct endpoints for class subjects and teachers
        // (Assume classSubjectsAPI and teachersAPI are imported)
        // If not, use api.get('/classes/class-subjects/', ...) and api.get('/auth/teachers/', ...)
        api.get('/classes/class-subjects/', { params: { class_id: classId } }),
        api.get('/auth/teachers/'),
      ]);
      setScheduleModal({ open: true, classId, schedule: Array.isArray(scheduleRes.data) ? scheduleRes.data : [] });
      setSubjects(subjectsRes.data.results || subjectsRes.data || []);
      setTeachers(teachersRes.data.results || teachersRes.data || []);
    } catch (err) {
      setModalError('Failed to load schedule.');
    } finally {
      setModalLoading(false);
    }
  };

  const handleOpenScheduleDialog = (entry?: any) => {
    if (entry && entry.id) {
      setEditingSchedule(entry);
      setScheduleForm({
        day: entry.day,
        start_time: entry.start_time,
        end_time: entry.end_time,
        subject: entry.subject?.id || entry.subject || '',
        teacher: entry.teacher?.id || entry.teacher || '',
        room: entry.room || '',
      });
    } else {
      setEditingSchedule(null);
      setScheduleForm({ ...emptyScheduleForm, ...(entry || {}) });
    }
    setScheduleDialogOpen(true);
  };
  const handleCloseScheduleDialog = () => {
    setScheduleDialogOpen(false);
    setEditingSchedule(null);
    setScheduleForm({ ...emptyScheduleForm });
  };
  const handleScheduleFormChange = (field: string, value: any) => {
    setScheduleForm(prev => ({ ...prev, [field]: value }));
  };
  const handleScheduleSubmit = async () => {
    setScheduleActionLoading(true);
    try {
      const data = {
        class_obj_id: scheduleModal.classId,
        subject_id: scheduleForm.subject,
        teacher_id: scheduleForm.teacher ? Number(scheduleForm.teacher) : null,
        day: scheduleForm.day,
        start_time: scheduleForm.start_time,
        end_time: scheduleForm.end_time,
        room: scheduleForm.room,
      };
      if (editingSchedule) {
        await api.put(`/classes/schedules/${editingSchedule.id}/`, data);
        setScheduleSnackbar({ open: true, message: 'Schedule updated', severity: 'success' });
      } else {
        await api.post('/classes/schedules/', data);
        setScheduleSnackbar({ open: true, message: 'Schedule added', severity: 'success' });
      }
      // Refresh schedule
      const res = await classesAPI.getClassSchedule(scheduleModal.classId!);
      setScheduleModal(modal => ({ ...modal, schedule: Array.isArray(res.data) ? res.data : [] }));
      handleCloseScheduleDialog();
    } catch (err: any) {
      let message = err.response?.data?.detail || 'Failed to save schedule';
      if (
        (err.response?.data && typeof err.response.data === 'string' && err.response.data.includes('UNIQUE constraint failed')) ||
        (err.response?.data?.detail && typeof err.response.data.detail === 'string' && err.response.data.detail.includes('UNIQUE constraint failed'))
      ) {
        message = 'A schedule already exists for this class, day, and period.';
      }
      setScheduleSnackbar({ open: true, message, severity: 'error' });
    } finally {
      setScheduleActionLoading(false);
    }
  };
  const handleScheduleDelete = async (id: number) => {
    setScheduleActionLoading(true);
    try {
      await api.delete(`/classes/schedules/${id}/`);
      setScheduleSnackbar({ open: true, message: 'Schedule deleted', severity: 'success' });
      // Refresh schedule
      const res = await classesAPI.getClassSchedule(scheduleModal.classId!);
      setScheduleModal(modal => ({ ...modal, schedule: Array.isArray(res.data) ? res.data : [] }));
    } catch (err: any) {
      setScheduleSnackbar({ open: true, message: err.response?.data?.detail || 'Failed to delete schedule', severity: 'error' });
    } finally {
      setScheduleActionLoading(false);
    }
  };

  // PDF download handler for class schedule
  const handleDownloadSchedulePDF = () => {
    if (!scheduleModal.classId || !scheduleModal.schedule.length) return;
    const classObj = classes.find(c => c.id === scheduleModal.classId);
    const className = classObj ? `${classObj.name}${classObj.section ? ' - ' + classObj.section : ''}` : 'Class';
    const academicYear = classObj?.academic_year || '';
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    const margin = 14;
    // Header
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.text(`Class Schedule: ${className}`, pageWidth / 2, margin, { align: 'center' });
    doc.setFontSize(12);
    doc.setFont('helvetica', 'normal');
    doc.text(`Academic Year: ${academicYear}`, pageWidth / 2, margin + 8, { align: 'center' });
    // Build table data
    const schedule = scheduleModal.schedule;
    const periods = Array.from(new Set(schedule.map(s => `${s.start_time}-${s.end_time}`))).sort();
    const grid = {} as { [period: string]: { [day: string]: any } };
    periods.forEach(period => {
      grid[period] = {};
      DAYS.forEach(day => {
        grid[period][day.value] = schedule.find(s => `${s.start_time}-${s.end_time}` === period && s.day === day.value);
      });
    });
    const head = [['Period', ...DAYS.map(day => day.label)]];
    const body = periods.map(period => {
      const [start, end] = period.split('-');
      const periodLabel = `${start.slice(0,5)} - ${end.slice(0,5)}`;
      return [
        periodLabel,
        ...DAYS.map(day => {
          const entry = grid[period][day.value];
          if (!entry) return '';
          let text = entry.subject?.name || '';
          if (includeTeacher && entry.teacher_info?.name) text += `\n${entry.teacher_info.name}`;
          if (includeRoom && entry.room) text += `\nRoom: ${entry.room}`;
          return text;
        })
      ];
    });
    autoTable(doc, {
      head,
      body,
      startY: margin + 18,
      styles: { fontSize: 10, cellPadding: 2 },
      headStyles: { fillColor: [22, 160, 133] },
      theme: 'grid',
      willDrawCell: function (data) {
        if (data.section === 'body' && data.cell.raw) {
          const lines = String(data.cell.raw).split('\n');
          if (lines.length > 1) {
            data.cell.text = [];
          }
        }
      },
      didDrawCell: function (data) {
        if (data.section === 'body' && data.cell.raw) {
          const lines = String(data.cell.raw).split('\n');
          const doc = data.doc;
          const textPos = typeof (data as any).cell.getTextPos === 'function'
            ? (data as any).cell.getTextPos()
            : (data as any).cell.textPos;
          if (!textPos) return;
          if (lines.length > 1) {
            // Draw subject (main) line bold
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(11);
            doc.text(lines[0], textPos.x, textPos.y, { baseline: 'top' });
            // Draw teacher/room lines smaller, italic, not bold
            doc.setFont('helvetica', 'italic');
            doc.setFontSize(9);
            const lineHeight = 5.5;
            for (let i = 1; i < lines.length; i++) {
              doc.text(lines[i], textPos.x, textPos.y + i * lineHeight, { baseline: 'top' });
            }
          }
        }
      },
    });
    doc.save(`class_schedule_${className.replace(/\s+/g, '_')}_${academicYear}.pdf`);
  };

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Classes Management
      </Typography>
      {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
      
      {/* Auto Generate and Year Filter Section */}
      <Card sx={{ mb: 2 }}>
        <CardContent>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
            <Typography variant="h6">
              Academic Year: {selectedYear || 'All Years'} 
              {totalCount > 0 && ` (${totalCount} classes)`}
            </Typography>
            <Box sx={{ display: 'flex', gap: 2 }}>
              {canManage && (
                <Button 
                  variant="outlined" 
                  startIcon={<AutoAwesome />} 
                  onClick={() => setAutoGenerateDialog(true)}
                  color="primary"
                >
                  Auto Generate Classes
                </Button>
              )}
              <Button variant="contained" startIcon={<Add />} onClick={() => handleOpenDialog()}>
                Add Class
              </Button>
            </Box>
          </Box>
          
          {/* Year Filter */}
          <Box sx={{ display: 'flex', gap: 2, alignItems: 'center' }}>
            <FormControl sx={{ minWidth: 200 }}>
              <InputLabel>Filter by Year</InputLabel>
              <Select
                value={selectedYear}
                onChange={(e) => handleYearChange(e.target.value)}
                label="Filter by Year"
              >
                <MenuItem value="">All Years</MenuItem>
                {academicYears.map((year) => (
                  <MenuItem key={year} value={year}>
                    {year}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Box>
        </CardContent>
      </Card>
      <Card>
        <CardContent>
          {loading ? (
            <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: 200 }}>
              <CircularProgress />
            </Box>
          ) : (
            <>
              <TableContainer component={Paper}>
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Name</TableCell>
                      <TableCell>Section</TableCell>
                      <TableCell>Academic Year</TableCell>
                      <TableCell>Capacity</TableCell>
                      <TableCell>Students</TableCell>
                      <TableCell>Subjects</TableCell>
                      <TableCell>Status</TableCell>
                      <TableCell>Actions</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {classes.map(cls => (
                      <TableRow key={cls.id}>
                        <TableCell>{cls.name}</TableCell>
                        <TableCell>{cls.section}</TableCell>
                        <TableCell>{cls.academic_year}</TableCell>
                        <TableCell>{cls.capacity}</TableCell>
                        <TableCell>
                          <Button size="small" startIcon={<Group />} onClick={() => handleViewStudents(cls.id)}>
                            {cls.students_count}
                          </Button>
                        </TableCell>
                        <TableCell>{cls.subjects_count}</TableCell>
                        <TableCell>
                          <Chip label={cls.is_active ? 'Active' : 'Inactive'} color={cls.is_active ? 'success' : 'default'} size="small" />
                        </TableCell>
                        <TableCell>
                          <Tooltip title="View Schedule">
                            <IconButton onClick={() => handleViewSchedule(cls.id)}>
                              <Schedule />
                            </IconButton>
                          </Tooltip>
                          {canManage && (
                            <>
                              <Tooltip title="Edit">
                                <IconButton onClick={() => handleOpenDialog(cls)}>
                                  <Edit />
                                </IconButton>
                              </Tooltip>
                              {((user?.role === 'school_admin') || (user?.role === 'principal')) && (
                                <Tooltip title="Delete">
                                  <IconButton onClick={() => handleDelete(cls.id)}><Delete color="error" /></IconButton>
                                </Tooltip>
                              )}
                            </>
                          )}
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
              {/* Pagination Controls */}
              {totalPages > 1 && (
                <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', mt: 2 }}>
                  <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                    Page {page} of {totalPages} â€¢ Showing {classes.length} of {totalCount} classes
                  </Typography>
                  <Pagination
                    count={totalPages}
                    page={page}
                    onChange={handlePageChange}
                    color="primary"
                  />
                </Box>
              )}
            </>
          )}
        </CardContent>
      </Card>

      {/* Other Years Compact View */}
      {academicYears.length > 1 && (
        <Card sx={{ mt: 2 }}>
          <CardContent>
            <Typography variant="h6" gutterBottom>
              {selectedYear ? 'Other Academic Years' : 'Academic Years'}
            </Typography>
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
              {yearCountsLoading ? (
                <CircularProgress size={20} />
              ) : (
                academicYears
                  .filter(year => !selectedYear || year !== selectedYear)
                  .map((year) => (
                    <Chip
                      key={year}
                      label={`${year} (${yearClassCounts[year] || 0} classes)`}
                      onClick={() => handleYearChange(year)}
                      variant="outlined"
                      clickable
                      color="primary"
                    />
                  ))
              )}
            </Box>
          </CardContent>
        </Card>
      )}
      {/* Add/Edit Dialog */}
      <Dialog open={dialogOpen} onClose={handleCloseDialog} maxWidth="sm" fullWidth>
        <DialogTitle>{editingId ? 'Edit Class' : 'Add Class'}</DialogTitle>
        <form onSubmit={handleFormSubmit}>
          <DialogContent>
            <Grid container spacing={2}>
              <Grid item xs={12} md={6} {...({ item: true } as any)}>
                <TextField
                  label="Name"
                  value={form.name}
                  onChange={e => handleFormChange('name', e.target.value)}
                  fullWidth
                  required
                  margin="dense"
                />
              </Grid>
              <Grid item xs={12} md={6} {...({ item: true } as any)}>
                <TextField
                  label="Section"
                  value={form.section}
                  onChange={e => handleFormChange('section', e.target.value)}
                  fullWidth
                  required
                  margin="dense"
                />
              </Grid>
              <Grid item xs={12} md={6} {...({ item: true } as any)}>
                <TextField
                  label="Academic Year"
                  value={form.academic_year}
                  onChange={e => handleFormChange('academic_year', e.target.value)}
                  fullWidth
                  required
                  margin="dense"
                />
              </Grid>
              <Grid item xs={12} md={6} {...({ item: true } as any)}>
                <TextField
                  label="Capacity"
                  type="number"
                  value={form.capacity}
                  onChange={e => handleFormChange('capacity', Number(e.target.value))}
                  fullWidth
                  required
                  margin="dense"
                  inputProps={{ min: 1 }}
                />
              </Grid>
              <Grid item xs={12} md={6} {...({ item: true } as any)}>
                <FormControlLabel
                  control={
                    <Checkbox
                      checked={form.is_active}
                      onChange={e => handleFormChange('is_active', e.target.checked)}
                    />
                  }
                  label="Active"
                />
              </Grid>
            </Grid>
          </DialogContent>
          <DialogActions>
            <Button onClick={handleCloseDialog}>Cancel</Button>
            <Button type="submit" variant="contained">{editingId ? 'Update' : 'Add'}</Button>
          </DialogActions>
        </form>
      </Dialog>
      {/* Students Modal */}
      <Dialog open={studentsModal.open} onClose={() => setStudentsModal({ open: false, classId: null, students: [] })} maxWidth="sm" fullWidth>
        <DialogTitle>Class Students</DialogTitle>
        <DialogContent>
          {modalLoading ? (
            <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: 100 }}>
              <CircularProgress />
            </Box>
          ) : modalError ? (
            <Alert severity="error">{modalError}</Alert>
          ) : (
            <TableContainer component={Paper}>
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell>Name</TableCell>
                    <TableCell>Student ID</TableCell>
                    <TableCell>Status</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {studentsModal.students.map(stu => (
                    <TableRow key={stu.id}>
                      <TableCell>{stu.user.first_name} {stu.user.last_name}</TableCell>
                      <TableCell>{stu.student_id}</TableCell>
                      <TableCell>
                        <Chip label={stu.academic_status} size="small" color={stu.academic_status === 'enrolled' ? 'success' : 'default'} />
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setStudentsModal({ open: false, classId: null, students: [] })}>Close</Button>
        </DialogActions>
      </Dialog>
      {/* Schedule Modal */}
      <Dialog open={scheduleModal.open} onClose={() => setScheduleModal({ open: false, classId: null, schedule: [] })} maxWidth="xl" fullWidth>
        <DialogTitle>Class Schedule</DialogTitle>
        <DialogContent>
          {modalLoading ? (
            <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: 100 }}>
              <CircularProgress />
            </Box>
          ) : modalError ? (
            <Alert severity="error">{modalError}</Alert>
          ) : (
            <>
              <Box sx={{ display: 'flex', gap: 2, mb: 2 }}>
                <FormControlLabel
                  control={<Checkbox checked={includeTeacher} onChange={e => setIncludeTeacher(e.target.checked)} />}
                  label="Include Teacher Names"
                />
                <FormControlLabel
                  control={<Checkbox checked={includeRoom} onChange={e => setIncludeRoom(e.target.checked)} />}
                  label="Include Room Numbers"
                />
              </Box>
              {canManage && (
                <Box sx={{ mb: 2, display: 'flex', justifyContent: 'flex-end' }}>
                  <Button
                    variant="contained"
                    startIcon={<Add />}
                    onClick={() => handleOpenScheduleDialog()}
                  >
                    Add Schedule Entry
                  </Button>
                </Box>
              )}
              <Box sx={{ overflowX: 'auto' }}>
                {/* Timetable grid */}
                {(() => {
                  const schedule = scheduleModal.schedule;
                  const periods = Array.from(new Set(schedule.map(s => `${s.start_time}-${s.end_time}`))).sort();
                  const grid: { [period: string]: { [day: string]: any } } = {};
                  periods.forEach(period => {
                    grid[period] = {};
                    DAYS.forEach(day => {
                      grid[period][day.value] = schedule.find(s => `${s.start_time}-${s.end_time}` === period && s.day === day.value);
                    });
                  });
                  return (
                    <table style={{ borderCollapse: 'collapse', width: '100%' }}>
                      <thead>
                        <tr>
                          <th style={{ border: '1px solid #ccc', padding: 8, minWidth: 120 }}>Period</th>
                          {DAYS.map(day => (
                            <th key={day.value} style={{ border: '1px solid #ccc', padding: 8 }}>{day.label}</th>
                          ))}
                        </tr>
                      </thead>
                      <tbody>
                        {periods.map(period => (
                          <tr key={period}>
                            <td style={{ border: '1px solid #ccc', padding: 8 }}>{(() => { const [start, end] = period.split('-'); return `${start.slice(0,5)} - ${end.slice(0,5)}`; })()}</td>
                            {DAYS.map(day => {
                              const entry = grid[period][day.value];
                              return (
                                <td key={day.value} style={{ border: '1px solid #ccc', padding: 4, minWidth: 120, minHeight: 40, verticalAlign: 'top' }}>
                                  {entry ? (
                                    <>
                                      <Typography variant="subtitle2">{entry.subject?.name}</Typography>
                                      <Typography variant="body2" color="text.secondary">{entry.teacher_info?.name || '-'}</Typography>
                                      <Typography variant="caption" color="text.secondary">{entry.room}</Typography>
                                      {canManage && (
                                        <Box sx={{ mt: 1 }}>
                                          <IconButton size="small" onClick={() => handleOpenScheduleDialog(entry)}><Edit fontSize="small" /></IconButton>
                                          <IconButton size="small" onClick={() => handleScheduleDelete(entry.id)}><Delete fontSize="small" color="error" /></IconButton>
                                        </Box>
                                      )}
                                    </>
                                  ) : (
                                    canManage && (
                                      <IconButton size="small" onClick={() => handleOpenScheduleDialog({ day: day.value, start_time: period.split('-')[0], end_time: period.split('-')[1], subject: '', teacher: '', room: '' })}>
                                        <Add fontSize="small" />
                                      </IconButton>
                                    )
                                  )}
                                </td>
                              );
                            })}
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  );
                })()}
              </Box>
            </>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setScheduleModal({ open: false, classId: null, schedule: [] })}>Close</Button>
          <Button
            variant="contained"
            onClick={handleDownloadSchedulePDF}
            disabled={!scheduleModal.schedule.length}
          >
            Download PDF
          </Button>
        </DialogActions>
      </Dialog>
      {/* Add/Edit Schedule Dialog */}
      <Dialog open={scheduleDialogOpen} onClose={handleCloseScheduleDialog} maxWidth="sm" fullWidth>
        <DialogTitle>{editingSchedule ? 'Edit Schedule' : 'Add Schedule'}</DialogTitle>
        <DialogContent>
          <FormControl fullWidth margin="normal">
            <InputLabel>Day</InputLabel>
            <Select value={scheduleForm.day} label="Day" onChange={e => handleScheduleFormChange('day', e.target.value)}>
              {DAYS.map(day => (
                <MenuItem key={day.value} value={day.value}>{day.label}</MenuItem>
              ))}
            </Select>
          </FormControl>
          <TextField
            label="Start Time"
            type="time"
            value={scheduleForm.start_time}
            onChange={e => handleScheduleFormChange('start_time', e.target.value)}
            fullWidth
            margin="normal"
            InputLabelProps={{ shrink: true }}
          />
          <TextField
            label="End Time"
            type="time"
            value={scheduleForm.end_time}
            onChange={e => handleScheduleFormChange('end_time', e.target.value)}
            fullWidth
            margin="normal"
            InputLabelProps={{ shrink: true }}
          />
          <FormControl fullWidth margin="normal">
            <InputLabel>Subject</InputLabel>
            <Select value={scheduleForm.subject} label="Subject" onChange={e => handleScheduleFormChange('subject', e.target.value)}>
              {subjects.map(subj => (
                <MenuItem key={subj.subject?.id || subj.subject} value={subj.subject?.id || subj.subject}>{subj.subject_name || subj.subject?.name}</MenuItem>
              ))}
            </Select>
          </FormControl>
          <FormControl fullWidth margin="normal">
            <InputLabel>Teacher</InputLabel>
            <Select value={scheduleForm.teacher} label="Teacher" onChange={e => handleScheduleFormChange('teacher', e.target.value)}>
              {teachers
                .filter(teacher => {
                  // Only show teachers assigned to the selected subject for this class
                  if (!scheduleForm.subject) return true;
                  return subjects.some(subj => (subj.subject?.id || subj.subject) === scheduleForm.subject && subj.teacher === teacher.id);
                })
                .map(teacher => (
                  <MenuItem key={teacher.id} value={teacher.id}>{teacher.user?.full_name || teacher.user?.username}</MenuItem>
                ))}
            </Select>
          </FormControl>
          <TextField
            label="Room"
            value={scheduleForm.room}
            onChange={e => handleScheduleFormChange('room', e.target.value)}
            fullWidth
            margin="normal"
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseScheduleDialog}>Cancel</Button>
          <Button variant="contained" onClick={handleScheduleSubmit} disabled={scheduleActionLoading}>{editingSchedule ? 'Update' : 'Add'}</Button>
        </DialogActions>
      </Dialog>
      <Snackbar
        open={scheduleSnackbar.open}
        autoHideDuration={4000}
        onClose={() => setScheduleSnackbar(prev => ({ ...prev, open: false }))}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert severity={scheduleSnackbar.severity} onClose={() => setScheduleSnackbar(prev => ({ ...prev, open: false }))}>
          {scheduleSnackbar.message}
        </Alert>
      </Snackbar>

      {/* Auto Generate Classes Dialog */}
      <Dialog open={autoGenerateDialog} onClose={() => setAutoGenerateDialog(false)} maxWidth="sm" fullWidth>
        <DialogTitle>Auto Generate Classes</DialogTitle>
        <DialogContent>
          <Box sx={{ mt: 2 }}>
            <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
              This will duplicate all classes from the most recent academic year ({latestYear}) to a new year.
            </Typography>
            
            {autoGenerateError && (
              <Alert severity="error" sx={{ mb: 2 }}>{autoGenerateError}</Alert>
            )}
            
            {autoGenerateSuccess && (
              <Alert severity="success" sx={{ mb: 2 }}>{autoGenerateSuccess}</Alert>
            )}
            
            <TextField
              label="Target Academic Year"
              value={targetYear}
              onChange={(e) => setTargetYear(e.target.value)}
              fullWidth
              required
              margin="dense"
              placeholder="e.g., 2026"
              helperText="Enter the academic year for the new classes"
            />
            
            <Typography variant="body2" color="text.secondary" sx={{ mt: 2 }}>
              <strong>Note:</strong> This will create new classes with the same grade names and sections but assigned to the new academic year.
            </Typography>
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setAutoGenerateDialog(false)}>Cancel</Button>
          <Button 
            onClick={handleAutoGenerate} 
            variant="contained" 
            disabled={autoGenerateLoading || !targetYear}
            startIcon={autoGenerateLoading ? <CircularProgress size={20} /> : <AutoAwesome />}
          >
            {autoGenerateLoading ? 'Generating...' : 'Generate Classes'}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default Classes; 